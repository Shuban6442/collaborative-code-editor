
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Session {{ session_id }}</title>
  <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/monaco-editor@0.34.1/min/vs/loader.js"></script>
  <style>
    :root {
      --bg: #0f172a;
      --panel: #111827;
      --panel-light: #1f2937;
      --text: #e5e7eb;
      --muted: #9ca3af;
      --accent: #3b82f6;
      --border: #2a3342;
    }

    body {
      margin: 0;
      font-family: system-ui, sans-serif;
      background: var(--bg);
      color: var(--text);
    }

    .topbar {
      display: flex;
      justify-content: space-between;
      padding: 10px 16px;
      background: #111827;
      border-bottom: 1px solid var(--border);
    }
    .brand { display: flex; gap: 10px; }
    .session-code { background: #1f2937; padding: 4px 8px; border-radius: 6px; }
    .actions { display: flex; gap: 8px; }

    .container { display: flex; height: calc(100vh - 50px); }
    .left { flex: 1; display: flex; flex-direction: column; }
    #editor { flex: 1; border-bottom: 1px solid var(--border); }
    .toolbar { padding: 8px; background: #111827; }
    .btn {
      padding: 6px 12px;
      border-radius: 6px;
      border: 1px solid var(--border);
      background: #1f2937;
      color: var(--text);
      cursor: pointer;
    }
    .btn.primary { background: #2563eb; border-color: #2563eb; }

    #output {
      padding: 10px;
      background: #0b1220;
      border-top: 1px solid var(--border);
      min-height: 80px;
      white-space: pre-wrap;
      font-family: monospace;
    }

    /* Participants drawer */
    #participantsDrawer {
      width: 320px;
      border-left: 1px solid var(--border);
      background: #0b1220;
      display: flex;
      flex-direction: column;
      transition: transform 0.3s ease;
      transform: translateX(100%);
    }
    #participantsDrawer.open {
      transform: translateX(0);
    }
    
    #plist { list-style: none; margin: 0; padding: 12px; flex: 1; overflow-y: auto; }
    #plist li {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 10px;
      margin-bottom: 8px;
      border: 1px solid var(--border);
      border-radius: 8px;
      background: #111827;
    }
    .p-info { display: flex; flex-direction: column; }
    .p-name { font-weight: 500; }
    .p-role { font-size: 12px; color: var(--muted); }
    .p-actions button {
      margin-left: 6px;
      padding: 4px 8px;
      font-size: 12px;
      border-radius: 6px;
      border: 1px solid #2a3b52;
      background: #1e293b;
      color: #e5e7eb;
      cursor: pointer;
    }
    .p-actions button:hover { background: #2563eb; border-color: #2563eb; }

    /* Writer banner */
    #writerBanner {
      text-align: center;
      padding: 6px;
      font-weight: bold;
      background: #1e3a8a;
      color: #fff;
      display: none;
    }

    /* Mic bar */
    #micControls { padding: 8px; background: #111827; display: flex; align-items: center; gap: 10px; }
    #micButton.active { background: red; }
    #micLevel { width: 200px; height: 10px; background: #333; border-radius: 4px; overflow: hidden; }
    #micLevelFill { height: 100%; width: 0; background: #3b82f6; }
  </style>
</head>
<body>
  <div class="topbar">
    <div class="brand">
      <span class="session-code">Session {{ session_id }}</span>
      <span class="badge">Python</span>
    </div>
    <div class="actions">
      <button id="participantsBtn" class="btn">Participants</button>
    </div>
  </div>

  <div id="writerBanner">‚úè You are the Writer</div>

  <div class="container">
    <div class="left">
      <div id="editor"></div>
      <div class="toolbar">
        <button id="runBtn" class="btn primary">Run</button>
        <button id="clearBtn" class="btn">Clear</button>
      </div>
      <div id="output"></div>

      <!-- Hidden input area -->
      <div id="inputArea" style="padding:10px; background:#111827; display:none;">
        <input id="inputBox" type="text" placeholder="Type input..." style="width:100%;" />
      </div>

      <!-- Mic controls -->
      <div id="micControls">
        <button id="micButton" class="btn">üé§ Mic Off</button>
        <div id="micLevel"><div id="micLevelFill"></div></div>
      </div>
    </div>

    <div id="participantsDrawer">
      <h3 style="padding:12px; margin:0; border-bottom:1px solid var(--border);">Participants</h3>
      <ul id="plist"></ul>
    </div>
  </div>

  <script>
    const socket = io();
    const runBtn = document.getElementById("runBtn");
    const clearBtn = document.getElementById("clearBtn");
    const participantsBtn = document.getElementById("participantsBtn");
    const participantsDrawer = document.getElementById("participantsDrawer");
    const output = document.getElementById("output");
    const plist = document.getElementById("plist");
    const writerBanner = document.getElementById("writerBanner");

    const inputArea = document.getElementById("inputArea");
    const inputBox = document.getElementById("inputBox");

    const sessionId = "{{ session_id }}";
    const urlParams = new URLSearchParams(window.location.search);
    const myName = urlParams.get("name") || "Anonymous";

    let myRole = "participant";
    let mySid = null;
    let writerId = null;
    let editor;
    let running = false;

    // Load Monaco Editor
    require.config({ paths: { 'vs': 'https://cdn.jsdelivr.net/npm/monaco-editor@0.34.1/min/vs' }});
    require(["vs/editor/editor.main"], function () {
      editor = monaco.editor.create(document.getElementById("editor"), {
        value: "",
        language: "python",
        theme: "vs-dark",
        automaticLayout: true,
        readOnly: true
      });

      editor.onDidChangeModelContent(() => {
        if (mySid && mySid === writerId) {
          socket.emit("code_change", { session_id: sessionId, content: editor.getValue() });
        }
      });
    });

    // join session
    socket.emit("join_session", { session_id: sessionId, name: myName });
    socket.on("connect", () => { mySid = socket.id; });

    // sync code
    socket.on("code_update", data => {
      if (editor && mySid !== writerId) editor.setValue(data.content);
    });

    // participants
    socket.on("participants_update", data => {
      plist.innerHTML = "";
      writerId = data.writer_id;
      const hostId = data.host_id;

      for (const [sid, info] of Object.entries(data.participants)) {
        if (sid === mySid) myRole = info.role;

        const li = document.createElement("li");
        const infoDiv = document.createElement("div");
        infoDiv.className = "p-info";
        const nameSpan = document.createElement("span");
        nameSpan.className = "p-name";
        nameSpan.textContent = info.name + (sid === writerId ? " ‚úè" : "");
        const roleSpan = document.createElement("span");
        roleSpan.className = "p-role";
        roleSpan.textContent = info.role;
        infoDiv.appendChild(nameSpan); infoDiv.appendChild(roleSpan);

        const actionsDiv = document.createElement("div");
        actionsDiv.className = "p-actions";
        if (myRole === "host" && sid !== hostId) {
          const btn = document.createElement("button");
          btn.textContent = sid === writerId ? "Revoke" : "Grant";
          btn.onclick = () => socket.emit(sid === writerId ? "revoke_write" : "grant_write",
                                           { session_id: sessionId, target_sid: sid });
          actionsDiv.appendChild(btn);
        }

        li.appendChild(infoDiv);
        li.appendChild(actionsDiv);
        plist.appendChild(li);
      }

      if (editor) {
        const isWriter = mySid === writerId;
        editor.updateOptions({ readOnly: !isWriter });
        writerBanner.style.display = isWriter ? "block" : "none";
      }
    });

    // Run code
    runBtn.onclick = async () => {
      running = true;
      output.textContent = "[Program started]\n";
      inputArea.style.display = "block";

      const resp = await fetch("/run_code", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ code: editor.getValue(), session_id: sessionId })
      });
      const data = await resp.json();
      if (data.output) output.textContent += data.output;
    };

    socket.on("code_output", data => {
      output.textContent += data.output;
      output.scrollTop = output.scrollHeight;
    });

    inputBox.addEventListener("keydown", (e) => {
      if (e.key === "Enter" && running) {
        const text = inputBox.value.trim();
        if (text) {
          socket.emit("provide_input", { session_id: sessionId, text });
          inputBox.value = "";
          output.textContent += `\n[Input sent: ${text}]\n`;
        }
      }
    });

    clearBtn.onclick = () => {
      if (mySid === writerId) {
        editor.setValue("");
        socket.emit("code_change", { session_id: sessionId, content: "" });
      }
      output.textContent = "";
      inputArea.style.display = "none";
      running = false;
    };

    participantsBtn.addEventListener("click", () => { participantsDrawer.classList.toggle("open"); });

    // ---------------- MIC + WebRTC ----------------
    const micButton = document.getElementById("micButton");
    const micLevelFill = document.getElementById("micLevelFill");
    let localStream = null; // user mic stream when enabled
    let pcPeers = {};       // peerId -> RTCPeerConnection
    let audioContext, analyser, source, dataArray;

    micButton.onclick = async () => {
      if (micButton.classList.contains("active")) {
        stopMic();
      } else {
        await startMic();
      }
    };

    async function startMic() {
      try {
        localStream = await navigator.mediaDevices.getUserMedia({ audio: true });
        micButton.classList.add("active");
        micButton.textContent = "üé§ Mic On";

        audioContext = new AudioContext();
        analyser = audioContext.createAnalyser();
        source = audioContext.createMediaStreamSource(localStream);
        source.connect(analyser);
        dataArray = new Uint8Array(analyser.frequencyBinCount);
        requestAnimationFrame(updateMicLevel);

        // Add audio tracks to all existing peer connections and renegotiate
        for (const [peerId, pc] of Object.entries(pcPeers)) {
          localStream.getTracks().forEach(track => pc.addTrack(track, localStream));
          await renegotiateWithPeer(peerId);
        }
      } catch (err) {
        console.error("Mic error", err);
      }
    }

    async function stopMic() {
      if (localStream) {
        // Remove senders from each peer
        for (const [peerId, pc] of Object.entries(pcPeers)) {
          const senders = pc.getSenders().filter(s => s.track && s.track.kind === "audio");
          senders.forEach(s => pc.removeTrack(s));
          await renegotiateWithPeer(peerId).catch(() => {});
        }
        localStream.getTracks().forEach(track => track.stop());
        localStream = null;
      }
      micButton.classList.remove("active");
      micButton.textContent = "üé§ Mic Off";
    }

    function updateMicLevel() {
      if (!analyser) return;
      analyser.getByteFrequencyData(dataArray);
      let avg = dataArray.reduce((a, b) => a + b) / dataArray.length;
      micLevelFill.style.width = (avg / 2) + "px";
      requestAnimationFrame(updateMicLevel);
    }

    async function createPeerConnection(peerId) {
      if (pcPeers[peerId]) return pcPeers[peerId];
      const pc = new RTCPeerConnection({
        iceServers: [
          { urls: "stun:stun.l.google.com:19302" },
          // Public TURN for testing; for production use your own TURN
          { urls: ["turn:openrelay.metered.ca:80","turn:openrelay.metered.ca:443","turn:openrelay.metered.ca:443?transport=tcp"], username: "openrelayproject", credential: "openrelayproject" }
        ]
      });
      pcPeers[peerId] = pc;

      pc.onicecandidate = (event) => {
        if (event.candidate) {
          socket.emit("webrtc_ice_candidate", { target: peerId, candidate: event.candidate });
        }
      };

      pc.ontrack = (event) => {
        let audioElem = document.getElementById("remoteAudio_" + peerId);
        if (!audioElem) {
          audioElem = document.createElement("audio");
          audioElem.id = "remoteAudio_" + peerId;
          audioElem.autoplay = true;
          audioElem.playsInline = true;
          audioElem.muted = false;
          document.body.appendChild(audioElem);
        }
        console.log("üéß Playing remote audio from peer:", peerId);
        audioElem.srcObject = event.streams[0];
      };
      return pc;
    }

    async function renegotiateWithPeer(peerId) {
      const pc = pcPeers[peerId];
      if (!pc) return;
      const offer = await pc.createOffer();
      await pc.setLocalDescription(offer);
      socket.emit("webrtc_offer", { target: peerId, sdp: pc.localDescription });
    }

    socket.on("new_peer", async (data) => {
      const peerId = data.sid;
      const pc = await createPeerConnection(peerId);
      if (localStream) {
        localStream.getTracks().forEach(track => pc.addTrack(track, localStream));
      }
      await renegotiateWithPeer(peerId);
    });

    socket.on("audio_peers_list", async (data) => {
      for (const peerId of data.peers) {
        const pc = await createPeerConnection(peerId);
        if (localStream) {
          localStream.getTracks().forEach(track => pc.addTrack(track, localStream));
        }
        await renegotiateWithPeer(peerId);
      }
    });

    socket.on("webrtc_offer", async (data) => {
      const { sid, sdp } = data;
      const pc = await createPeerConnection(sid);
      if (localStream) {
        localStream.getTracks().forEach(track => pc.addTrack(track, localStream));
      }
      await pc.setRemoteDescription(new RTCSessionDescription(sdp));
      const answer = await pc.createAnswer();
      await pc.setLocalDescription(answer);
      socket.emit("webrtc_answer", { target: sid, sdp: pc.localDescription });
    });

    socket.on("webrtc_answer", async (data) => {
      const { sid, sdp } = data;
      const pc = pcPeers[sid];
      if (pc) {
        await pc.setRemoteDescription(new RTCSessionDescription(sdp));
      }
    });

    socket.on("webrtc_ice_candidate", async (data) => {
      const { sid, candidate } = data;
      const pc = pcPeers[sid];
      if (pc && candidate) {
        try {
          await pc.addIceCandidate(new RTCIceCandidate(candidate));
        } catch (err) {
          console.error("ICE error", err);
        }
      }
    });

    // Join WebRTC room immediately on session join so peers connect regardless of mic state
    socket.emit("webrtc_join", { session_id: sessionId });
    socket.emit("request_audio_peers", { session_id: sessionId });

    // Cleanup when a peer leaves
    socket.on("peer_left", (data) => {
      const { sid } = data;
      const pc = pcPeers[sid];
      if (pc) {
        try { pc.close(); } catch (_) {}
        delete pcPeers[sid];
      }
      const audioElem = document.getElementById("remoteAudio_" + sid);
      if (audioElem) {
        audioElem.srcObject = null;
        audioElem.remove();
      }
    });

    // Cleanup on page unload
    window.addEventListener("beforeunload", () => {
      for (const [peerId, pc] of Object.entries(pcPeers)) {
        try { pc.close(); } catch (_) {}
        const audioElem = document.getElementById("remoteAudio_" + peerId);
        if (audioElem) {
          audioElem.srcObject = null;
          audioElem.remove();
        }
      }
      pcPeers = {};
      if (localStream) {
        localStream.getTracks().forEach(t => t.stop());
        localStream = null;
      }
    });
  </script>
</body>
</html>
